'use strict';

import interceptor from 'express-interceptor';
import memoryStore from './memory-store';
import { success, error } from './utils';

const defaultConfig = {
    limitWindow: 60 * 1000,    //interval before rate limiting is triggered (in milliseconds)
    limitCredits: 100,         //credits when reset
    creditsRemaining: 100,     //initial credits
};
let activeKeyGen;
let activeStore;

/**
 * create credits based rate limiting when req is received
 * 
 * @param {object} [config=defaultConfig] see 'defaultConfig'
 * @param {function} [keyGen=(req) => req.ip] a key generate from req
 * @param {object} [store=memoryStore] store to cache rate limiting information
 * @returns express middleware
 */
function reqRateLimit({config = defaultConfig, keyGen = (req) => req.ip, store = memoryStore}) {
    activeKeyGen = keyGen;
    activeStore = store;
    return async (req, res, next) => {
        let key = activeKeyGen(req);
        let pr = null;
        try {
            let rateLimit = await activeStore.get(key);
            if (Date.now() - rateLimit.lastAccessAt > rateLimit.limitWindow) {
                //reset
                rateLimit.creditsRemaining = rateLimit.limitCredits;
                rateLimit.lastAccessAt = Date.now();
                pr = activeStore.set(key, rateLimit, rateLimit.limitWindow * 1.5);
            }
            else {
                if (rateLimit.creditsRemaining > 0) {
                    //update access
                    rateLimit.lastAccessAt = Date.now();
                    pr = activeStore.set(key, rateLimit, rateLimit.limitWindow * 1.5);
                }
                else {
                    //triggered
                    resRateLimiting(res, rateLimit);
                    return;
                }
            }
            pr.then(() => next())
                .catch((err) => {
                    resInternalError(res);
                });
        }
        catch (err) {
            activeStore.set(key, { ...config, lastAccessAt: Date.now() }, config.limitWindow * 1.5)
                .then(() => next())
                .catch((err) => {
                    resInternalError(res);
                });
        }
    };
}

/**
 * add rate limiting header before response sent & update credits
 * should be used after middleware generated by reqRateLimit()
 * 
 * @returns express middleware
 */
function resRateLimit() {
    return interceptor((req, res) => ({
        isInterceptable: () => true,
        intercept: (body, send) => {
            if (res.creditsConsumed != undefined) {
                let key = activeKeyGen(req);
                activeStore.get(key)
                    .then((rateLimit) => {
                        rateLimit.creditsRemaining = Math.max(rateLimit.creditsRemaining - res.creditsConsumed, 0);
                        //need a store.update(key, value) semantic which memcached does not support
                        activeStore.set(key, rateLimit, rateLimit.limitWindow);
                        return rateLimit;
                    })
                    .then((rateLimit) => {
                        res.setHeader('Rate-Limit-Limit', rateLimit.limitCredits);
                        res.setHeader('Rate-Limit-Remaining', rateLimit.creditsRemaining);
                        res.setHeader('Rate-Limit-Used', res.creditsConsumed);
                        res.setHeader('Rate-Limit-Reset', 0);
                    })
                    .then(() => send(body))
                    .catch((err) => {
                        error(err.message);
                        resInternalError(res);
                    });
            }
            else {
                send(body);
            }
        }
    }))
}

/**
 * set default credits associated with specified handler
 * 
 * @param {function} handler (req, res) handler
 * @param {any} credits default credits
 * @returns 
 */
function creditsConsumer(handler, credits) {
    return (req, res) => {
        res.creditsConsumed = credits;
        return handler(req, res);
    }
}

function resRateLimiting(res, rateLimit) {
    res.setHeader('Rate-Limit-Limit', rateLimit.limitCredits);
    res.setHeader('Rate-Limit-Remaining', rateLimit.creditsRemaining);
    res.setHeader('Rate-Limit-Used', 0);
    res.setHeader('Rate-Limit-Reset', Math.round((rateLimit.lastAccessAt + rateLimit.limitWindow - Date.now()) / 1000));
    res.status(429).json({
        message: 'Too Many Requests'
    });
}

function resInternalError(res) {
    res.status(500).end();
}

export { reqRateLimit, resRateLimit, creditsConsumer };